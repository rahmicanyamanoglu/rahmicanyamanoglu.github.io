<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wine Runner | R. Can Yamanoƒülu</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=DM+Sans:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">

    <style>
        /* Game-specific overrides */
        header {
            position: sticky;
            top: 0;
            z-index: 9999;
            background: var(--paper);
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        #game-section {
            padding: 40px 20px;
            background: #fffbf5;
        }

        #game-section h2 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .game-description {
            text-align: center;
            max-width: 800px;
            margin: 0 auto 30px;
            font-family: 'DM Sans', sans-serif;
            color: var(--muted);
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            max-width: 1900px;
            margin: 0 auto 30px;
            aspect-ratio: 1900/850;
            background: linear-gradient(180deg, #1a0206, #050002);
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(43, 20, 32, 0.2);
            border: 4px solid #2b1420;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #hud {
            position: absolute;
            top: 12px;
            left: 20px;
            font-family: 'DM Sans', sans-serif;
            font-size: clamp(12px, 1.2vw, 15px);
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            color: #f0f4ff;
            pointer-events: none;
            z-index: 2;
            line-height: 1.3;
        }

        #message {
            position: absolute;
            bottom: 12%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(18px, 2.5vw, 28px);
            font-weight: bold;
            color: #ffd95b;
            text-shadow: 0 2px 8px rgba(0,0,0,0.9);
            display: none;
            z-index: 2;
            text-align: center;
            background: rgba(0,0,0,0.6);
            padding: 8px 16px;
            border-radius: 8px;
        }

        #dialog-overlay, #start-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(8, 0, 12, 0.85);
            z-index: 10;
        }

        .start-box, .dialog-box {
            background: rgba(20, 10, 15, 0.95);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            color: #f0f4ff;
            border: 2px solid rgba(255, 150, 150, 0.3);
            max-width: 500px;
        }

        .start-box h2 { font-size: 2.5rem; color: #ffd95b; margin-bottom: 20px; }
        .start-box p { font-size: 1.2rem; margin: 10px 0; font-family: 'DM Sans', sans-serif; }

        button {
            margin: 10px;
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            background: #ffd95b;
            color: #2b1420;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            font-family: 'Cormorant Garamond', serif;
            transition: transform 0.1s, background 0.2s;
        }

        button:hover { transform: translateY(-2px); background: #ffea9e; }

        .hidden { display: none !important; }

        .game-controls {
            max-width: 1900px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(139, 69, 19, 0.05);
            border: 1px solid var(--border);
            border-radius: 8px;
        }
        .game-controls ul {
            list-style: none;
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
            padding: 0;
        }
        .game-controls li { font-family: 'DM Sans', sans-serif; color: var(--muted); }
        kbd {
            background: #fff;
            padding: 2px 6px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
            box-shadow: 0 2px 0 var(--border);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <img src="images/profile.jpg" alt="R. Can Yamanoƒülu" class="profile-photo">
                <div>
                    <h1 class="name"><a href="index.html" class="name-link">Rahmi <span>Can</span> Yamanoƒülu</a></h1>
                    <p class="title">PhD Candidate in Economic Geography & Regional Science</p>
                    <p class="affiliation">
                        <a href="https://www.gssi.it/" target="_blank">Gran Sasso Science Institute</a><br>
                        L'Aquila, Italy
                    </p>
                </div>
                <nav>
                    <a href="index.html">About</a>
                    <a href="research.html">Research</a>
                    <a href="education.html">Education</a>
                    <a href="essays.html">Essays</a>
                    <a href="game.html" class="active">Game</a>
                    <a href="contact.html">Contact</a>
                </nav>
            </div>
        </header>

        <section id="game-section">
            <h2>Wine Runner</h2>

            <h3 class="subsection">About the Game</h3>
            <div class="game-description">
                <p>Navigate wine regions where collective trademarks and geographical indications protect reputation against free-riders. Build trust, collect IP rights, and defend against those who exploit collective efforts‚Äîbased on my research on inclusive innovation in traditional industries.</p>
            </div>

            <h3 class="subsection">Play</h3>
            <div id="game-wrapper">
                <canvas id="game" width="1900" height="850"></canvas>

                <div id="hud"></div>
                <div id="message"></div>

                <div id="start-overlay">
                    <div class="start-box">
                        <h2>Inclusive Innovation</h2>
                        <p>Use <kbd>Arrow Keys</kbd> to Move & Jump</p>
                        <p>Press <kbd>F</kbd> to throw Trademarks (or Trust in boss fight!)</p>
                        <button id="start-btn">Click to Start Game</button>
                    </div>
                </div>

                <div id="dialog-overlay" class="hidden">
                    <div class="dialog-box">
                        <p id="dialog-text">Freerider Boss: ...</p>
                        <button id="dialog-continue">Fight!</button>
                    </div>
                </div>
            </div>

            <h3 class="subsection">Controls</h3>
            <div class="game-controls">
                <ul>
                    <li><kbd>‚Üê</kbd> <kbd>‚Üí</kbd> Move</li>
                    <li><kbd>‚Üë</kbd> or <kbd>Space</kbd> Jump</li>
                    <li><kbd>Shift</kbd> Dash</li>
                    <li><kbd>F</kbd> Throw Trademark/Trust</li>
                    <li><kbd>R</kbd> Restart</li>
                </ul>
            </div>
        </section>

        <footer>
            <p>¬© 2025 R. Can Yamanoƒülu</p>
        </footer>
    </div>

    <script>
        // --- Game Setup & Variables ---
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const hud = document.getElementById("hud");
        const message = document.getElementById("message");
        const dialogOverlay = document.getElementById("dialog-overlay");
        const dialogText = document.getElementById("dialog-text");
        const dialogContinue = document.getElementById("dialog-continue");

        const startOverlay = document.getElementById("start-overlay");
        const startBtn = document.getElementById("start-btn");
        let gameActive = false;

        // Polyfill for roundRect
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
                const r = typeof radius === "number" ? radius : 8;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + width, y, x + width, y + height, r);
                this.arcTo(x + width, y + height, x, y + height, r);
                this.arcTo(x, y + height, x, y, r);
                this.arcTo(x, y, x + width, y, r);
                return this;
            };
        }

        // --- Constants ---
        const WIDTH = 1900;
        const HEIGHT = 850;
        const GROUND = HEIGHT - 80;
        const GRAVITY = 3000;
        const FRICTION = 0.64;
        const PLAYER_SPEED = 660;
        const JUMP_FORCE = 660;
        const DASH_FORCE = 780;
        const DASH_COOLDOWN = 1.2;
        const TRADEMARK_COOLDOWN = 0.35;
        const TRADEMARK_SPEED = 820;
        const GOAL_FRIEND_BUFFER = 220;

        const ENVIRONMENTS = [
            {
                id: "high",
                name: "High-Trust Environment",
                description: "Collective action flows easily; free riders hesitate.",
                trustMultiplier: 1.25,
                enemySpeedMultiplier: 0.8,
                grapeTheft: false,
                trademarkDelta: 3,
                tmStatus: "Trademarks increasing",
                goalLabel: "GI",
                colors: { skyTop: "#092550", skyMid: "#0b1c3d", skyBottom: "#050a16", hill: "#0e264a", soil: "#091324", vineTint: [90, 150, 200] },
                introMessage: "High-trust environment: reach the glowing door to file the GI!",
                transitionMessage: "GI charter sealed! But CTMs are next‚Äîbrace for low trust.",
            },
            {
                id: "low",
                name: "Low-Trust Environment",
                description: "Fragmented governance; free riders dash to steal grapes.",
                trustMultiplier: 0.95,
                enemySpeedMultiplier: 1.2,
                grapeTheft: true,
                trademarkDelta: -4,
                tmStatus: "Trademarks decreasing",
                goalLabel: "CT",
                colors: { skyTop: "#41030c", skyMid: "#240006", skyBottom: "#0b0002", hill: "#300109", soil: "#160002", vineTint: [210, 50, 50] },
                introMessage: "Low-trust crisis! Free riders and weakened trademarks.",
                extraCollectibles: [
                    { x: 200, y: null, spec: { type: "grape", color: "#d4afff", label: "Community Harvest" } },
                    { x: 500, y: null, spec: { type: "grape", color: "#d4afff", label: "Shared Plot" } },
                    { x: 900, y: null, spec: { type: "gi", color: "#91e0c0", label: "Emergency Charter" } },
                ],
                extraEnemies: [{ x: 620, range: 130, speed: 170 }, { x: 1180, range: 120, speed: 170 }],
            },
            {
                id: "boss",
                name: "Freerider Citadel",
                description: "Face the freerider who steals reputation and exploits collective IP.",
                trustMultiplier: 1,
                enemySpeedMultiplier: 1,
                grapeTheft: false,
                trademarkDelta: 6,
                tmStatus: "Final showdown",
                goalLabel: "IP",
                colors: { skyTop: "#1d030f", skyMid: "#120006", skyBottom: "#050001", hill: "#2a0208", soil: "#160003", vineTint: [240, 120, 150] },
                introMessage: "The Freerider Boss blocks the path ‚Äì throw trust to defend collective reputation!",
                bossConfig: {
                    health: 16,
                    taunts: [
                        "Freerider Boss: \"Your collective intellectual property? I'll steal the reputation anyway!\"",
                        "Freerider Boss: \"GIs protect nothing ‚Äì I freeride on your collective efforts!\"",
                        "Freerider Boss: \"Why build reputation when I can appropriate yours?\"",
                        "Freerider Boss: \"Your trademarks won't help ‚Äì I'll steal again and again!\"",
                    ],
                },
            },
        ];

        // --- Game State ---
        let environmentIndex = 0;
        let currentEnvironment = ENVIRONMENTS[environmentIndex];

        const VINE_ROWS = 5;
        const vineField = [];
        const stars = [];
        const particles = [];
        const projectiles = [];
        const trademarkBursts = [];
        const playerProjectiles = [];

        let surferHelper = null;
        let surferRescueUsed = false;
        let surferSequenceActive = false;
        let playerHasMoved = false;
        let enemyHoldTimer = Infinity;
        let enemiesPaused = true;

        let boss = null;
        let bossActive = false;
        let bossDefeated = false;
        let bossTauntQueue = [];
        let bossTauntTimer = null;
        let bossConversationActive = false;

        let friendDancePhase = 0;
        const gateFriends = [{ offsetX: -60, color: "#ffe4e4" }, { offsetX: -30, color: "#ffd1c1" }, { offsetX: 10, color: "#ffc6d9" }];

        const keys = {};

        // --- Audio ---
        let musicCtx = null;
        let musicTimer = null;
        let musicActive = false;
        const NOTE_FREQ = { G3: 196.00, A3: 220.00, B3: 246.94, C4: 261.63, D4: 293.66, E4: 329.63, F4: 349.23, G4: 392.00, A4: 440.00, B4: 493.88, C5: 523.25, D5: 587.33, E5: 659.25, F5: 698.46, G5: 783.99 };
        const musicPattern = [
            { notes: ["E4"], duration: 0.32 }, { notes: ["E4"], duration: 0.32 }, { notes: ["F4"], duration: 0.32 },
            { notes: ["G4"], duration: 0.32 }, { notes: ["G4"], duration: 0.32 }, { notes: ["F4"], duration: 0.32 },
            { notes: ["E4"], duration: 0.32 }, { notes: ["D4"], duration: 0.32 }, { notes: ["C4"], duration: 0.32 },
            { notes: ["C4"], duration: 0.32 }, { notes: ["D4"], duration: 0.32 }, { notes: ["E4"], duration: 0.32 },
            { notes: ["E4"], duration: 0.48 }, { notes: ["D4"], duration: 0.16 }, { notes: ["D4"], duration: 0.64 }
        ];

        // --- Inputs ---
        startBtn.addEventListener("click", () => {
            startOverlay.classList.add("hidden");
            gameActive = true;
            startMusic();
            resetGame();
        });

        if (dialogContinue) dialogContinue.addEventListener("click", advanceBossDialogue);

        window.addEventListener("keydown", e => {
            if(gameActive && ["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) {
                e.preventDefault();
            }

            if (!gameActive) return;

            const key = e.key.toLowerCase();

            if (bossConversationActive) {
                advanceBossDialogue();
                return;
            }
            keys[key] = true;
            if (key === "r" && gameOver) resetGame();
            if (key === "f" || key === "k") attemptTrademarkThrow();
            if (["arrowleft","arrowright","a","d","w","s","arrowup","arrowdown"," ","shift","q"].includes(key)) registerPlayerMovement();
        });

        window.addEventListener("keyup", e => { keys[e.key.toLowerCase()] = false; });

        // --- Helpers ---
        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
        function rand(min, max) { return Math.random() * (max - min) + min; }

        function initBackdrop() {
            if (!stars.length) {
                for (let i = 0; i < 70; i++) stars.push({ x: rand(0, WIDTH), y: rand(10, HEIGHT * 0.55), size: rand(1, 3), speed: rand(5, 20), alpha: rand(0.4, 0.9) });
            }
            if (!vineField.length) {
                for (let i = 0; i < VINE_ROWS; i++) vineField.push({ y: GROUND + 10 + i * 12, color: `rgba(${100 + i * 10}, ${120 + i * 15}, ${90 + i * 8}, 0.4)`, sway: rand(0.2, 0.6) });
            }
        }

        // --- Classes ---
        class Player {
            constructor() { this.reset(); }
            reset() {
                this.x = 140; this.y = GROUND - 30; this.vx = 0; this.vy = 0;
                this.width = 32; this.height = 40; this.onGround = false; this.dashTimer = 0;
                this.health = 3; this.trust = 0; this.grapes = 0; this.giCharters = 0;
                this.ctmCharters = 0; this.innovation = 0; this.trademarks = 0;
                this.trademarkCooldown = 0; this.facing = 1;
            }
            update(dt) {
                if (keys["arrowright"] || keys["d"]) { this.vx = PLAYER_SPEED; this.facing = 1; }
                else if (keys["arrowleft"] || keys["a"]) { this.vx = -PLAYER_SPEED; this.facing = -1; }
                else { this.vx *= FRICTION; }

                if ((keys["w"] || keys["arrowup"] || keys[" "]) && this.onGround) {
                    this.vy = -JUMP_FORCE; this.onGround = false; keys["w"] = keys["arrowup"] = keys[" "] = false;
                }
                this.trademarkCooldown = Math.max(0, this.trademarkCooldown - dt);

                if ((keys["shift"] || keys["q"]) && this.dashTimer <= 0) {
                    this.vx += Math.sign(this.vx || 1) * DASH_FORCE;
                    this.dashTimer = DASH_COOLDOWN;
                    showMessage("Dash!", 0.6);
                }
                this.dashTimer -= dt;
                this.vy += GRAVITY * dt;
                this.vy = Math.min(this.vy, 1500);
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                if (this.y + this.height >= GROUND) {
                    this.y = GROUND - this.height; this.vy = 0; this.onGround = true;
                }
                this.x = clamp(this.x, 0, WIDTH - this.width);
            }
            draw() {
                ctx.save();
                const bodyGrad = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
                bodyGrad.addColorStop(0, "#9ce9ff"); bodyGrad.addColorStop(1, "#419ad8");
                ctx.fillStyle = bodyGrad;
                ctx.beginPath(); ctx.roundRect(this.x, this.y, this.width, this.height, 10); ctx.fill();
                ctx.fillStyle = "#ffd7a8";
                ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y - 6, 10, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }

        class Collectible {
            constructor(x, y, spec) {
                this.x = x; this.y = y; this.type = spec.type; this.color = spec.color;
                this.label = spec.label; this.radius = spec.type === "ctm" ? 14 : 11;
                this.collected = false;
            }
            draw() {
                ctx.beginPath(); ctx.fillStyle = this.color;
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = "#05060c"; ctx.font = "10px 'Segoe UI'";
                ctx.textAlign = "center"; ctx.fillText(this.type.toUpperCase(), this.x, this.y + 3);
            }
        }

        class Obstacle {
            constructor(x, width, height) { this.x = x; this.width = width; this.height = height; }
            draw() { ctx.fillStyle = "#46352b"; ctx.fillRect(this.x, GROUND - this.height, this.width, this.height); }
        }

        class Enemy {
            constructor(x, range, baseSpeed = 90) {
                this.x = x; this.baseX = x; this.range = range;
                this.width = 36; this.height = 48; this.y = GROUND - this.height;
                this.dir = 1; this.speed = baseSpeed; this.alive = true;
                this.chaseTimer = 0; this.vy = 0; this.jumpTimer = rand(1.2, 2.6); this.fireTimer = rand(1.1, 2.2);
            }
            update(dt, multiplier = 1, target = null) {
                if (!this.alive) return;
                this.jumpTimer -= dt;
                if (this.jumpTimer <= 0 && this.onGround()) { this.vy = -JUMP_FORCE * 0.55; this.jumpTimer = rand(1.2, 2.6); }
                this.vy += GRAVITY * 0.8 * dt; this.y += this.vy * dt;
                if (this.y >= GROUND - this.height) { this.y = GROUND - this.height; this.vy = 0; }

                const center = this.x + this.width / 2;
                const playerCenter = target ? target.x + target.width / 2 : center;
                if (target && Math.abs(playerCenter - center) < 300) {
                    this.chaseTimer = 1.2; this.dir = playerCenter >= center ? 1 : -1;
                }
                const chaseBoost = this.chaseTimer > 0 ? 2.1 : 1.1;
                this.x += this.dir * this.speed * multiplier * chaseBoost * dt;
                if (this.x > WIDTH - this.width) this.x = WIDTH - this.width;
                if (this.x < 0) this.x = 0;
                if (this.chaseTimer <= 0) {
                    if (this.x > this.baseX + this.range) this.dir = -1;
                    if (this.x < this.baseX - this.range) this.dir = 1;
                }
                this.chaseTimer = Math.max(0, this.chaseTimer - dt);
                this.fireTimer -= dt;
                if (this.fireTimer <= 0 && target) {
                    fireProjectile(this, this.dir); this.fireTimer = rand(0.9, 1.8);
                }
            }
            onGround() { return this.y >= GROUND - this.height - 1; }
            draw() {
                if (!this.alive) return;
                ctx.save(); ctx.fillStyle = "#ff6b6b";
                ctx.beginPath(); ctx.roundRect(this.x, this.y + 12, this.width, this.height - 12, 12); ctx.fill();
                ctx.fillStyle = "#ffd4c4"; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + 12, 12, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = "#420000"; ctx.lineWidth = 2; ctx.strokeRect(this.x - 6, this.y + 24, this.width + 12, 8);
                ctx.restore();
            }
        }

        class Boss {
            constructor(config = {}) {
                this.width = 200; this.height = 220; this.maxHealth = config.health || 14;
                this.health = this.maxHealth; this.fireBase = config.fireCooldown || 1.4;
                this.fireTimer = 1.6; this.phase = 0;
                this.x = WIDTH - this.width - 180; this.y = GROUND - this.height; this.color = "#c99268";
            }
            isAlive() { return this.health > 0; }
            takeDamage(amount = 1) {
                if (!this.isAlive()) return false;
                this.health = Math.max(0, this.health - amount);
                return this.health === 0;
            }
            update(dt, target, active = false) {
                this.phase += dt;
                if (!active || !this.isAlive()) return;
                this.fireTimer -= dt;
                if (this.fireTimer <= 0) {
                    bossFirePatent(this, target);
                    this.fireTimer = Math.max(0.8, this.fireBase + rand(-0.2, 0.3));
                }
            }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
            draw() {
                if (!this.isAlive()) return;
                ctx.save();
                const bob = Math.sin(this.phase * 2) * 4;
                const sway = Math.sin(this.phase * 1.4) * 10;
                ctx.translate(this.x + sway, this.y + bob);
                ctx.fillStyle = "#2c1f2b"; ctx.fillRect(0, this.height - 60, this.width, 60);
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.roundRect(20, 80, this.width - 40, this.height - 160, 50); ctx.fill();
                ctx.fillStyle = "#f2c9b1"; ctx.beginPath(); ctx.arc(this.width / 2, 40, 40, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = "#1b1b1b"; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.arc(this.width / 2 - 22, 40, 18, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(this.width / 2 + 22, 40, 18, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(this.width / 2 - 4, 40); ctx.lineTo(this.width / 2 + 4, 40); ctx.stroke();
                const margin = 8;
                ctx.fillStyle = "#2b1f26"; ctx.fillRect(margin, this.height - 50, this.width - margin * 2, 20);
                const ratio = this.health / this.maxHealth;
                ctx.fillStyle = ratio > 0.5 ? "#8bff8f" : ratio > 0.25 ? "#ffd35c" : "#ff6b6b";
                ctx.fillRect(margin + 2, this.height - 48, (this.width - margin * 2 - 4) * ratio, 16);
                ctx.restore();
            }
        }

        class KoaHelper {
            constructor(target) {
                this.target = target; this.x = WIDTH + 200; this.y = 80;
                this.speed = 520; this.targetX = WIDTH / 2 - 40; this.targetY = GROUND - 90;
                this.state = "enter";
                this.dialogLines = ["Koa: \"Aloha, friend!\"", "Koa: \"Trust in the collective!\"", "Koa: \"Keep the faith!\""];
                this.dialogIndex = 0; this.dialogTimer = 0; this.waveTime = 0;
            }
            update(dt) {
                this.waveTime += dt;
                if(this.state === "enter") {
                    this.x -= this.speed * dt; this.y = 80 + Math.sin(this.waveTime * 4) * 40;
                    if (this.x <= this.targetX) { this.state = "dialogue"; this.dialogTimer = 0; showMessage(this.dialogLines[0], 2); }
                } else if(this.state === "dialogue") {
                    this.dialogTimer += dt;
                    if (this.dialogTimer >= 2.1) {
                        this.dialogIndex++;
                        if (this.dialogIndex < this.dialogLines.length) { this.dialogTimer = 0; showMessage(this.dialogLines[this.dialogIndex], 2); }
                        else {
                            player.health = Math.min(3, player.health + 1); surferRescueUsed = true;
                            showMessage("Koa: \"Ride on!\"", 1.8); this.state = "exit";
                        }
                    }
                } else if(this.state === "exit") {
                    this.x -= this.speed * dt; this.y -= dt * 60;
                    if (this.x < -200) { surferSequenceActive = false; surferHelper = null; }
                }
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.rotate(Math.sin(this.waveTime * 4) * 0.15);
                ctx.fillStyle = "#ff8c42"; ctx.beginPath(); ctx.ellipse(50, 25, 90, 16, 0.2, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = "#f4e3c3"; ctx.beginPath(); ctx.arc(20, -5, 12, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = "#6cd2ff"; ctx.fillRect(14, 8, 12, 40);
                ctx.restore();
            }
        }

        class Goal {
            constructor(x) { this.x = x; this.width = 28; this.height = 96; }
            draw(environment) {
                const accent = environment?.id === "low" ? "#f26c7f" : "#8be0c9";
                ctx.save(); ctx.translate(this.x, GROUND - this.height);
                ctx.fillStyle = "#2d354f"; ctx.beginPath(); ctx.moveTo(0, this.height);
                ctx.lineTo(0, 20); ctx.quadraticCurveTo(this.width / 2, 0, this.width, 20); ctx.lineTo(this.width, this.height); ctx.fill();
                ctx.strokeStyle = accent; ctx.lineWidth = 4; ctx.stroke();
                ctx.fillStyle = accent; ctx.font = "bold 18px 'Segoe UI'"; ctx.textAlign = "center";
                ctx.fillText((environment?.goalLabel || "GI"), this.width / 2, this.height / 2);
                ctx.restore();
            }
        }

        // --- Collision & Logic Helpers ---
        function rectsOverlap(a, b) {
            return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
        }
        function playerHitsCollectible(player, collectible) {
            const dx = player.x + player.width / 2 - collectible.x;
            const dy = player.y + player.height / 2 - collectible.y;
            return Math.hypot(dx, dy) < collectible.radius + Math.max(player.width, player.height) / 2;
        }
        function maybeSummonSurfer() {
            if (surferRescueUsed || surferHelper) return;
            if (player.health === 1 && !gameOver) {
                surferHelper = new KoaHelper(player); surferSequenceActive = true;
                showMessage("Koa is rushing to help!", 1.5);
            }
        }

        // --- Setup Definitions ---
        const baseCollectibleDefs = [
            { x: 280, y: GROUND - 60, spec: { type: "gi", color: "#91e0c0", label: "GI Charter" } },
            { x: 520, y: GROUND - 90, spec: { type: "ctm", color: "#f5c37c", label: "CTM Sprint" } },
            { x: 720, y: GROUND - 70, spec: { type: "gi", color: "#91e0c0", label: "PDO Upgrade" } },
            { x: 920, y: GROUND - 120, spec: { type: "ctm", color: "#f5c37c", label: "Brand Collab" } },
            { x: 1130, y: GROUND - 70, spec: { type: "grape", color: "#c88bff", label: "Micro Innovation" } },
            { x: 1290, y: GROUND - 110, spec: { type: "gi", color: "#91e0c0", label: "GI Booster" } },
            { x: 1400, y: GROUND - 90, spec: { type: "ctm", color: "#f5c37c", label: "Consortium Pact" } },
        ];
        const baseEnemyDefs = [
            { x: 240, range: 90, speed: 150 }, { x: 480, range: 100, speed: 170 }, { x: 760, range: 80, speed: 160 },
            { x: 1030, range: 100, speed: 155 }, { x: 1240, range: 90, speed: 150 }, { x: 1380, range: 70, speed: 145 },
        ];
        const baseObstacleDefs = [
            { x: 320, width: 130, height: 60 }, { x: 580, width: 160, height: 50 }, { x: 800, width: 150, height: 80 },
            { x: 1020, width: 160, height: 54 }, { x: 1220, width: 130, height: 70 }, { x: 1340, width: 110, height: 60 },
        ];

        let obstacles = [];
        const goal = new Goal(WIDTH - 120);
        let player = new Player();
        let collectibles = [];
        let enemies = [];

        function buildCollectibles() {
            const defs = [...baseCollectibleDefs];
            if (currentEnvironment.extraCollectibles) currentEnvironment.extraCollectibles.forEach(e => defs.push({ x: e.x, y: e.y ?? GROUND - 60, spec: e.spec }));
            return defs.map(d => new Collectible(d.x, d.y, d.spec));
        }
        function buildEnemies() {
            if (currentEnvironment?.bossConfig) return [];
            const defs = [...baseEnemyDefs];
            if (currentEnvironment.extraEnemies) defs.push(...currentEnvironment.extraEnemies);
            return defs.map(d => new Enemy(d.x, d.range, d.speed));
        }
        function buildObstacles() {
            const shuffled = baseObstacleDefs.map(d => ({ ...d }));
            shuffled.forEach(d => {
                d.x += rand(-80, 80);
                d.x = clamp(d.x, 80, goal.x - d.width - GOAL_FRIEND_BUFFER);
            });
            return shuffled.map(d => new Obstacle(d.x, d.width, d.height));
        }

        let lastTime = 0;
        let gameOver = false;
        let win = false;
        let messageTimeout = null;

        function showMessage(text = "", duration = 2) {
            if (!message) return;
            if (messageTimeout) clearTimeout(messageTimeout);
            message.textContent = text;
            message.style.display = text ? "block" : "none";
            if (text && duration > 0) messageTimeout = setTimeout(() => { message.style.display = "none"; }, duration * 1000);
        }

        // --- Audio Logic ---
        function startMusic() {
            if (musicActive) return;
            const AudioCtx = window.AudioContext || window.webkitAudioContext;
            if (!AudioCtx) return;
            if (!musicCtx || musicCtx.state === "closed") musicCtx = new AudioCtx();
            else if (musicCtx.state === "suspended") musicCtx.resume();

            let idx = 0;
            const playNote = () => {
                if (!musicCtx || musicCtx.state === "closed") return;
                const note = musicPattern[idx];
                note.notes.forEach((name, idxVoice) => {
                    const osc = musicCtx.createOscillator();
                    const gain = musicCtx.createGain();
                    osc.type = idxVoice === 0 ? "square" : "triangle";
                    osc.frequency.value = NOTE_FREQ[name] || 440;
                    gain.gain.value = idxVoice === 0 ? 0.1 : 0.05;
                    gain.gain.exponentialRampToValueAtTime(0.01, musicCtx.currentTime + note.duration * 0.9);
                    osc.connect(gain).connect(musicCtx.destination);
                    osc.start();
                    osc.stop(musicCtx.currentTime + note.duration);
                });
                idx = (idx + 1) % musicPattern.length;
                musicTimer = setTimeout(playNote, note.duration * 1000);
            };
            musicActive = true;
            playNote();
        }

        // --- Core Game Functions ---
        function startEnvironment(index, { preserveStats = false, showIntro = true } = {}) {
            environmentIndex = index;
            currentEnvironment = ENVIRONMENTS[environmentIndex];
            collectibles = buildCollectibles();
            enemies = buildEnemies();
            obstacles = buildObstacles();
            projectiles.length = 0;
            trademarkBursts.length = 0;
            playerProjectiles.length = 0;
            surferHelper = null;
            surferSequenceActive = false;
            playerHasMoved = false;
            enemyHoldTimer = Infinity;
            enemiesPaused = true;
            bossTauntQueue = [];
            if (currentEnvironment.bossConfig) {
                boss = new Boss(currentEnvironment.bossConfig);
                bossDefeated = bossActive = false;
                beginBossDialogue("Freerider Boss: \"Your collective IP means nothing when I steal your reputation. Trademarks won't save you from free-riding!\"");
            } else {
                boss = null;
                dialogOverlay.classList.add("hidden");
            }

            // Add Mega Enemy random chance
            if (!currentEnvironment.bossConfig && Math.random() < 0.45) {
                const mega = new Enemy(rand(200, WIDTH - 200), 140, 110);
                mega.width = 80; mega.height = 110; mega.y = GROUND - mega.height;
                enemies.push(mega);
            }

            if (!preserveStats) player.reset();
            else {
                player.x = 140; player.y = GROUND - player.height;
                player.vx = 0; player.vy = 0; player.onGround = false;
            }
            gameOver = win = false;
            if (showIntro && currentEnvironment.introMessage) showMessage(currentEnvironment.introMessage, 3.5);
        }

        function resetGame() {
            startEnvironment(0, { preserveStats: false });
            lastTime = performance.now();
        }

        function spawnParticles(x, y, color) {
            for (let i = 0; i < 8; i++) particles.push({ x, y, vx: rand(-60, 60), vy: rand(-120, -20), life: rand(0.4, 0.8), color });
        }
        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i]; p.life -= dt;
                if (p.life <= 0) { particles.splice(i, 1); continue; }
                p.vy += 200 * dt; p.x += p.vx * dt; p.y += p.vy * dt;
            }
        }
        function drawParticles() {
            particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.life); ctx.fillRect(p.x, p.y, 4, 4); ctx.globalAlpha = 1; });
        }

        function bossFirePatent(entity, target) {
            const sourceX = entity.x + entity.width / 2; const sourceY = entity.y + 40;
            const targetX = target ? target.x + target.width / 2 : sourceX - 1;
            const dir = Math.sign(targetX - sourceX) || -1;
            projectiles.push({ x: sourceX, y: sourceY, vx: dir * 320, vy: -80 + Math.random() * 160, life: 3, kind: "patent" });
            showMessage("Freerider attack incoming!", 0.7);
        }
        function startBossTaunts(lines = []) {
            if (bossTauntTimer) clearTimeout(bossTauntTimer);
            bossTauntQueue = [...lines];
            const advanceTaunt = () => {
                if (!bossTauntQueue.length) { bossActive = true; showMessage("Prove trust + trademarks defend collective reputation!", 2); return; }
                showMessage(bossTauntQueue.shift(), 2.6);
                bossTauntTimer = setTimeout(advanceTaunt, 2600);
            };
            advanceTaunt();
        }
        function beginBossDialogue(message) {
            bossConversationActive = true;
            dialogOverlay.classList.remove("hidden");
            dialogText.innerHTML = message;
            dialogContinue.style.display = "inline-block";
        }
        function advanceBossDialogue() {
            if (!bossConversationActive) return;
            bossConversationActive = false;
            dialogOverlay.classList.add("hidden");
            showMessage(`You: "With good governance and trust, we can make it!"`, 2.5);
            setTimeout(() => startBossTaunts(currentEnvironment.bossConfig?.taunts || []), 1200);
        }
        function registerPlayerMovement() {
            if (playerHasMoved) return;
            playerHasMoved = true; enemyHoldTimer = 1; enemiesPaused = true;
            showMessage("Free riders mobilize in 1 second!", 1.1);
        }
        function attemptTrademarkThrow() {
            if (gameOver || player.trademarkCooldown > 0) return;
            player.trademarkCooldown = TRADEMARK_COOLDOWN;
            playerProjectiles.push({ x: player.x + player.width/2 + player.facing*24, y: player.y + player.height/2 - 6, vx: player.facing * TRADEMARK_SPEED, life: 1.1 });
        }
        function fireProjectile(enemy, dir) {
            projectiles.push({ x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2, vx: dir * rand(260, 360), vy: rand(-40, 40), life: 2.5, kind: "enemy" });
        }

        // --- Main Loop ---
        function update(timestamp) {
            if (lastTime === 0) lastTime = timestamp;
            let dt = Math.min((timestamp - lastTime) / 1000, 0.016);
            lastTime = timestamp;
            friendDancePhase += dt * 6;

            if(!gameActive) return;

            if (playerHasMoved && enemiesPaused && Number.isFinite(enemyHoldTimer)) {
                enemyHoldTimer -= dt; if (enemyHoldTimer <= 0) { enemiesPaused = false; enemyHoldTimer = null; }
            }
            if (gameOver) return;

            player.update(dt);

            const speedMult = currentEnvironment.enemySpeedMultiplier || 1;
            if (!enemiesPaused && !surferSequenceActive) {
                enemies.forEach(e => {
                    e.update(dt, speedMult, player);
                    if (currentEnvironment.grapeTheft) {
                        collectibles.forEach(i => {
                            if (i.collected || i.type !== "grape") return;
                            if (Math.hypot(e.x + e.width/2 - i.x, e.y - i.y) < 50) {
                                i.collected = true; player.trust = Math.max(0, player.trust - 4);
                                showMessage("Free rider stole innovation!", 1.2);
                            }
                        });
                    }
                });
            }
            if (boss && !surferSequenceActive) boss.update(dt, player, bossActive);
            if (surferHelper) surferHelper.update(dt);

            obstacles.forEach(o => {
                if (rectsOverlap(player, { x: o.x, y: GROUND - o.height, width: o.width, height: o.height })) {
                    if (player.y + player.height - player.vy*dt <= GROUND - o.height) { player.y = GROUND - o.height - player.height; player.vy = 0; player.onGround = true; }
                    else if (player.y - player.vy*dt >= GROUND) { player.y = GROUND; player.vy = 0; }
                    else if (player.x < o.x + o.width/2) { player.x = o.x - player.width - 1; player.vx = 0; }
                    else { player.x = o.x + o.width + 1; player.vx = 0; }
                }
            });

            collectibles.forEach(i => {
                if (!i.collected && playerHitsCollectible(player, i)) {
                    i.collected = true;
                    if(i.type === "gi") { player.giCharters++; player.trust += 6; player.innovation+=4; showMessage("GI Adopted!", 1.5); }
                    else if(i.type === "ctm") { player.ctmCharters++; player.trust += 3; player.innovation+=6; showMessage("CTM Sprint!", 1.5); }
                    else { player.grapes++; player.innovation+=2; showMessage("Micro Innovation!", 1.2); }
                    spawnParticles(i.x, i.y, i.color);
                }
            });

            for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                const s = playerProjectiles[i]; s.life -= dt; s.x += s.vx * dt;
                if (s.life <= 0) { playerProjectiles.splice(i, 1); continue; }

                // Obstacle collision for projectiles
                let hitObstacle = false;
                for(let o of obstacles) {
                    if(rectsOverlap({x:s.x-10,y:s.y-10,width:20,height:20}, {x:o.x, y:GROUND-o.height, width:o.width, height:o.height})) {
                        playerProjectiles.splice(i, 1); hitObstacle = true; break;
                    }
                }
                if(hitObstacle) continue;

                let hit = false;
                enemies.forEach(e => {
                    if(e.alive && rectsOverlap({x:s.x-10,y:s.y-10,width:20,height:20}, e)) {
                        e.alive = false; playerProjectiles.splice(i, 1); hit = true;
                        player.trust += 2; spawnParticles(e.x+e.width/2, e.y, "#ffd95b");
                        trademarkBursts.push({x:e.x+e.width/2, y:e.y, vy:-80, life:0.9});
                    }
                });
                if(hit) continue;
                if(boss && bossActive && boss.isAlive() && rectsOverlap({x:s.x-10,y:s.y-10,width:20,height:20}, boss.getRect())) {
                    playerProjectiles.splice(i, 1);
                    if(boss.takeDamage(1)) {
                        bossDefeated = true; bossActive = false; win=true; gameOver=true;
                        showMessage("Freerider Boss Defeated! Inclusive Innovation!", 4);
                    } else {
                        showMessage("Trust Strike!", 0.8);
                    }
                    spawnParticles(boss.x+boss.width/2, boss.y+boss.height/2, "#8be0ff");
                }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i]; p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt; p.vy += 120 * dt;
                if (p.life <= 0) { projectiles.splice(i, 1); continue; }
                if (rectsOverlap({x:p.x-6,y:p.y-6,width:12,height:12}, player)) {
                    projectiles.splice(i, 1); player.health--; maybeSummonSurfer();
                    if (player.health <= 0) { gameOver = true; showMessage("Game Over", 3); }
                }
            }

            // Burst update
            for(let i=trademarkBursts.length-1; i>=0; i--) {
                let t = trademarkBursts[i]; t.life -= dt; t.y += t.vy * dt; t.vy -= 30*dt;
                if(t.life <= 0) trademarkBursts.splice(i, 1);
            }

            enemies.forEach(e => {
                if(e.alive && rectsOverlap(player, e)) {
                    if(player.vy > 0) { e.alive = false; player.vy = -JUMP_FORCE*0.6; player.trust+=4; }
                    else { player.health--; player.vx = -Math.sign(e.dir||1)*200; maybeSummonSurfer(); if(player.health<=0) { gameOver=true; showMessage("Game Over",3); } }
                }
            });

            if(boss && bossActive && boss.isAlive() && rectsOverlap(player, boss.getRect())) {
                 player.health--; player.vx = -220; maybeSummonSurfer();
                 if(player.health<=0) { gameOver=true; showMessage("Game Over",3); }
            }

            if (player.x > goal.x && !boss) {
                if (environmentIndex < ENVIRONMENTS.length - 1) {
                    player.x = 0; startEnvironment(environmentIndex + 1, { preserveStats: true });
                } else {
                    win = true; gameOver = true; showMessage("You Won! Inclusive Innovation!", 4);
                }
            }

            updateParticles(dt);
            if(player.y > HEIGHT + 40) { gameOver = true; showMessage("Game Over", 3); }

            // HUD
            const trustIcon = player.trust >= 20 ? "ü§ù" : "ü§î";
            hud.innerHTML = `
                <div><strong>${currentEnvironment.name}</strong></div>
                <div>Health: ${"‚ù§".repeat(player.health)} | Trust ${trustIcon}: ${player.trust} | Wines: ${player.grapes}</div>
                <div>GI: ${player.giCharters} | CTM: ${player.ctmCharters}</div>
            `;
            if (boss && boss.isAlive()) {
               hud.innerHTML += `<div>Freerider Boss Health: ${boss.health}/${boss.maxHealth}</div>`;
            }
        }

        function draw() {
            // Draw Background
            const c = currentEnvironment.colors;
            const g = ctx.createLinearGradient(0,0,0,HEIGHT);
            g.addColorStop(0, c.skyTop); g.addColorStop(1, c.skyBottom);
            ctx.fillStyle = g; ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = "#fff"; stars.forEach(s => ctx.fillRect(s.x, s.y, s.size, s.size));

            // Hills
            ctx.fillStyle = c.hill || "#0b1e36";
            ctx.beginPath();
            ctx.moveTo(0, GROUND - 60);
            ctx.quadraticCurveTo(WIDTH * 0.3, GROUND - 110, WIDTH * 0.6, GROUND - 40);
            ctx.quadraticCurveTo(WIDTH * 0.85, GROUND, WIDTH, GROUND - 30);
            ctx.lineTo(WIDTH, HEIGHT); ctx.lineTo(0, HEIGHT); ctx.fill();

            // Soil
            ctx.fillStyle = c.soil; ctx.fillRect(0, GROUND, WIDTH, HEIGHT-GROUND);
            vineField.forEach((v, idx) => {
                ctx.fillStyle = v.color;
                const sway = Math.sin(Date.now()*0.001 + idx) * v.sway;
                for(let x=0; x<WIDTH; x+=40) ctx.fillRect(x + sway*5, v.y, 30, 4);
            });

            goal.draw(currentEnvironment);

            gateFriends.forEach((f, idx) => {
                const x = goal.x - 40 + f.offsetX;
                ctx.fillStyle = f.color;
                ctx.beginPath(); ctx.arc(x, GROUND - 90 + Math.sin(friendDancePhase+idx)*5, 12, 0, Math.PI*2); ctx.fill();
                ctx.fillRect(x-12, GROUND-80, 24, 40);
            });

            if(boss) boss.draw();
            if(surferHelper) surferHelper.draw();
            obstacles.forEach(o => o.draw());
            collectibles.forEach(i => !i.collected && i.draw());
            enemies.forEach(e => e.draw());

            // Projectiles - show "TRUST" in boss fight, "TM" otherwise
            const isBossFight = boss && bossActive;
            playerProjectiles.forEach(p => {
                ctx.save();
                ctx.fillStyle = isBossFight ? "#8be0ff" : "#ffd95b";
                ctx.beginPath(); ctx.arc(p.x, p.y, 10, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#3a1f04";
                ctx.font = isBossFight ? "bold 8px sans-serif" : "bold 10px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText(isBossFight ? "TRUST" : "TM", p.x, p.y+4);
                ctx.restore();
            });
            projectiles.forEach(p => { ctx.fillStyle=p.kind==="patent"?"#f9d764":"#ff3030"; ctx.beginPath(); ctx.ellipse(p.x, p.y, p.kind==="patent"?10:6, p.kind==="patent"?6:3, 0, 0, Math.PI*2); ctx.fill(); });

            // Trademark bursts
            ctx.fillStyle = "#ffd95b";
            trademarkBursts.forEach(t => { ctx.globalAlpha = Math.max(0, t.life); ctx.beginPath(); ctx.arc(t.x, t.y, 8, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha=1; });

            drawParticles();
            player.draw();

            if (gameOver) {
                ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0, 0, WIDTH, HEIGHT);
                ctx.fillStyle = "#fff"; ctx.font = "bold 40px 'Cormorant Garamond'"; ctx.textAlign = "center";
                ctx.fillText(win ? "Inclusive Innovation Triggered!" : "Game Over", WIDTH / 2, HEIGHT / 2);
                ctx.font = "24px 'DM Sans'";
                ctx.fillText("Press R to Restart", WIDTH / 2, HEIGHT / 2 + 50);
            }
        }

        function loop(timestamp) {
            update(timestamp);
            draw();
            requestAnimationFrame(loop);
        }

        initBackdrop();
        startEnvironment(0);
        draw();
        requestAnimationFrame(loop);
    </script>
</body>
</html>
